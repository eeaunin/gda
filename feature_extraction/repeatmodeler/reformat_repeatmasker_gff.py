#!/usr/bin/env python3
"""
Script for splitting the simple and complex repeat lines in RepeatMasker GFF output and reformatting the GFF so that it can be used as the input for the multiple_gff_features_to_bedgraph.py script
"""
# MIT License
# 
# Copyright (c) 2020-2021 Genome Research Ltd.
# 
# Author: Eerik Aunin (ea10@sanger.ac.uk)
# 
# This file is a part of the Genome Decomposition Analysis (GDA) pipeline.
# 
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
# 
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

import os.path, sys
sys.path.append(os.path.join(os.path.dirname(os.path.realpath(__file__)), os.pardir))
import general_purpose_functions as gpf
import argparse

def generate_gff_header(fasta_path):
    """
    Generates a GFF3 header based on scaffold names and lengths read from a FASTA file
    """
    gff_header = list()
    gff_header.append("##gff-version 3")
    fasta_data = gpf.read_fasta_in_chunks(fasta_path)
    for header, seq in fasta_data:
        seq_len = len(seq)
        gff_header_line = "##sequence-region   {} 1 {}".format(header, str(seq_len))
        gff_header.append(gff_header_line)
    return gff_header


def generate_reformated_gff(fasta_path, repeatmasker_gff_path, repeat_type):
    """
    Filters RepeatMasker output GFF to keep only complex or only simple repeat families.
    Also reformats the GFF (replaces the third column with repeat description)
    Ouput: list of strings where each item is a line of the GFF file
    """
    out_gff_list = generate_gff_header(fasta_path)

    in_gff_list = gpf.l(repeatmasker_gff_path)
    in_gff_list = [n for n in in_gff_list if n.startswith("##") == False]
    if repeat_type == "complex":
        in_gff_list = [n for n in in_gff_list if "Motif:rnd" in n]
    elif repeat_type == "simple":
        in_gff_list = [n for n in in_gff_list if "Motif:(" in n]

    for line in in_gff_list:
        split_line = line.split("\t")
        rnd_family = split_line[8]
        rnd_family = rnd_family.split("\"")[1]
        rnd_family = rnd_family.split(":")[1]
        split_line[2] = rnd_family
        out_line = "\t".join(split_line)
        out_gff_list.append(out_line)
    return out_gff_list


def main(fasta_path, repeatmasker_gff_path, repeat_type, out_path):
    out_gff_list = generate_reformated_gff(fasta_path, repeatmasker_gff_path, repeat_type)
    gpf.export_list_as_line_break_separated_file(out_gff_list, out_path)


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument("fasta_path", type=str, help="Path to assembly FASTA file")
    parser.add_argument("repeatmasker_gff_path", type=str, help="Path to the GFF file generated by RepeatMasker")
    parser.add_argument("repeat_type", type=str, help="Type of repeats to be extracted (\"simple\" or \"complex\")", choices=["simple", "complex"])
    parser.add_argument("out_path", type=str, help="Path for output file")
    args = parser.parse_args()
    main(args.fasta_path, args.repeatmasker_gff_path, args.repeat_type, args.out_path)




