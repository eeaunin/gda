#!/usr/bin/env Rscript 
# Script for using RepeatModeler's repeat families output for detecting repeats that are enriched at scaffold edges
# This is not a component of the main pipeline of GDA but can be used as an extra step to get more information out of the data

# Argument1: path to the tab separated table that has been generated by merging bedgraph files of the decomposition pipeline
# Argument2: assembly ID, e.g. idSyrPip1
# Argument3: assembly title, e.g. Syritta pipiens
# Argument4: path to folder for output files
# Argument5: length of scaffold edge (max distance from the scaffold end, bp)
# Argument6: chunk size (window length)
# Argument7: heatmap width
# Argument8: heatmap height
# Argument9: boolean that determines whether column labels are shown on the heatmap

# MIT License
# 
# Copyright (c) 2020-2021 Genome Research Ltd.
# 
# Author: Eerik Aunin (ea10@sanger.ac.uk)
# 
# This file is a part of the Genome Decomposition Analysis (GDA) pipeline.
# 
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
# 
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

library("gplots")

is_repeatmodeler_column <- function(col_name) {
  repeatmodeler_column_flag <- FALSE
  if(startsWith(col_name, "complex_repeats_rnd.") == TRUE | startsWith(col_name, "simple_repeats_") == TRUE) {
    repeatmodeler_column_flag <- TRUE
  }
  return(repeatmodeler_column_flag)
}

args <- commandArgs(trailingOnly = TRUE)
in_path <- args[1]
assembly_id <- args[2]
assembly_title <- args[3]
out_folder <- args[4]
edge_length_in_nucleotides <- as.integer(args[5])
window_size_in_nucleotides <- as.integer(args[6])
heatmap_width <- as.integer(args[7])
heatmap_height <- as.integer(args[8])
heatmap_column_labels_flag <- as.logical(args[9])

df <- read.csv(in_path, stringsAsFactors=FALSE, sep="\t")
scaffs <- unique(df$chromosome)

scaff_end_means_df <- NULL
scaff_middle_means_df <- NULL

ends_segment_count <- 0
middle_segment_count <- 0

edge_length <- ceiling(edge_length_in_nucleotides/window_size_in_nucleotides)

for(selected_scaff in scaffs) {
  ind <- which(df$chromosome == selected_scaff)
  df2 <- df[ind,]
  df2_row_count <- nrow(df2)
  
  if(df2_row_count > edge_length) {
    repeatmodeler_cols_vect <- sapply(colnames(df2), is_repeatmodeler_column)
    ind <- which(repeatmodeler_cols_vect == TRUE)
    df2 <- df2[,ind]
    
    df2_head <- df2[1:edge_length,]
    df2_middle <- df2[(edge_length + 1):(df2_row_count-(edge_length)),]
    df2_tail <- df2[(df2_row_count-edge_length + 1):df2_row_count,]
    
    ends_segment_count <- ends_segment_count + nrow(df2_head) + nrow(df2_tail)
    middle_segment_count <- middle_segment_count + nrow(df2_middle)
    
    selected_scaff_head <- colSums(df2_head) * window_size_in_nucleotides
    selected_scaff_tail <- colSums(df2_tail) * window_size_in_nucleotides
    
    scaff_end_means_df <- rbind(scaff_end_means_df, selected_scaff_head)
    rownames(scaff_end_means_df)[nrow(scaff_end_means_df)] <- paste0(selected_scaff, "_head")
    scaff_end_means_df <- rbind(scaff_end_means_df, selected_scaff_tail)
    rownames(scaff_end_means_df)[nrow(scaff_end_means_df)] <- paste0(selected_scaff, "_tail")
    scaff_middle_means_df <- rbind(scaff_middle_means_df, colSums(df2_middle) * window_size_in_nucleotides)
  }
}

summary_df <- rbind(colSums(scaff_end_means_df), colSums(scaff_middle_means_df))
rownames(summary_df) <- c("scaff_end_sums", "scaff_middle_sums")
summary_df <- t(summary_df)
summary_df <- as.data.frame(summary_df)

ends_to_middle_ratio <- ends_segment_count / middle_segment_count

summary_df$total <- summary_df$scaff_end_sums + summary_df$scaff_middle_sums
summary_df$scaff_end_expected <- round(summary_df$total * ends_to_middle_ratio, 0)
summary_df$scaff_middle_expected <- round(summary_df$total * (1- ends_to_middle_ratio), 0)

fisher_pvals_vect <- NULL
chisq_pvals_vect <- NULL

for(i in 1:nrow(summary_df)) {
  summary_df_row <- summary_df[i,]
  summary_vect <- as.integer(c(summary_df_row["scaff_end_sums"], summary_df_row["scaff_middle_sums"], summary_df_row["scaff_end_expected"], summary_df_row["scaff_middle_expected"]))
  test_mat <- matrix(summary_vect, ncol=2)
  fisher_result <- fisher.test(test_mat)
  chisq_result <- chisq.test(test_mat)
  fisher_pvals_vect <- c(fisher_pvals_vect, fisher_result$p.value)
  chisq_pvals_vect <- c(chisq_pvals_vect, chisq_result$p.value)
}

summary_df$chisq_pval <- chisq_pvals_vect
summary_df$chisq_pval_adjusted <- p.adjust(chisq_pvals_vect, method="BH")
summary_df$fisher_pval <- fisher_pvals_vect
summary_df$fisher_pval_adjusted <- p.adjust(fisher_pvals_vect, method="BH")

ind <- which(summary_df$scaff_end_sums > summary_df$scaff_end_expected & summary_df$chisq_pval_adjusted < 0.05)
summary_df <- summary_df[ind,]

summary_df$ratio <- summary_df$scaff_end_sums/summary_df$scaff_middle_sums
summary_df <- summary_df[order(summary_df$ratio, decreasing=TRUE),]

selected_repeats <- rownames(summary_df)
ind <- which(is.element(colnames(scaff_end_means_df), selected_repeats))

selected_repeats_df <- scaff_end_means_df[,ind]
keep_vect <- NULL
for(i in 1:ncol(selected_repeats_df)) {
  ind <- which(selected_repeats_df[,i] > 0)
  if(length(ind) > 1) {
    keep_vect <- c(keep_vect, i)
  }
}

selected_repeats_df2 <- selected_repeats_df[,keep_vect]



export_colnames_flag <- TRUE
if(export_colnames_flag) {
  colnames_file <- paste0(out_folder, "/", assembly_id, "_", "repeats_enriched_at_scaff_ends.txt")
  file_conn <- file(colnames_file)
  writeLines(colnames(selected_repeats_df2), file_conn)
  close(file_conn)
}


my_palette <- colorRampPalette(c("blue", "yellow"))(n = 100)
heatmap_mat <- t(as.matrix(selected_repeats_df2))

out_df <- heatmap_mat
table_out_path <- paste0(out_folder, "/", assembly_id, "_", "repeats_enriched_at_scaff_ends.csv")
write.csv(out_df, table_out_path, quote=FALSE)

heatmap_mat <- log2(heatmap_mat)
heatmap_mat[is.infinite(heatmap_mat)] <- 0
heatmap_mat <- heatmap_mat[,order(colnames(heatmap_mat), decreasing=FALSE)]
heatmap_mat <- heatmap_mat[order(rownames(heatmap_mat)), ]

heatmap_out_path <- paste0(out_folder, "/", assembly_id, "_", "repeats_enriched_at_scaff_ends_heatmap.png")

save_heatmap_flag <- TRUE
if(save_heatmap_flag) {
  png(heatmap_out_path, height=heatmap_height, width=heatmap_width, units="in", res=350) 
  heatmap.2(heatmap_mat,
            main = paste0(assembly_title, "\n repeats that are enriched at scaffold ends"), 
            col=my_palette,
            density.info="none",  
            trace="none",         
            margins =c(12,16),     
            dendrogram="none",
            lhei=c(0.5,4), lwid=c(1,4),
            Colv="NA",
            Rowv=FALSE,
            labCol=heatmap_column_labels_flag
            )
  dev.off()
}



